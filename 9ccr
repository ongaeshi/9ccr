#! /usr/bin/env ruby
require 'strscan'

#
# Tokenizer
#
TK_RESERVED = 0
TK_NUM = 1
TK_EOF = 2

# Token type
Token = Struct.new(
  :kind, # Token kind
  :next, # Next token
  :val,  # If kind is TK_NUM, its value
  :str,  # Token string
  :pos   # Token position in user_input
)

# Input program
@user_input = nil

# Current token
@token = nil

# Reports an error and exit.
def error(msg)
  STDERR.puts msg
  exit(1)
end

# Reports an error location and exit.
def error_at(msg, pos)
  STDERR.puts @user_input
  STDERR.puts " " * pos + "^ " 
  STDERR.puts msg
  exit(1)
end

# Consumes the current token if it matches `op`.
def consume(op)
  if @token.kind != TK_RESERVED || @token.str != op
    return false
  end
  @token = @token.next
  true
end

# Ensure that the current token is `op`.
def expect(op)
  if @token.kind != TK_RESERVED || @token.str != op
    error_at("expected '#{op}'", @token.pos)
  end
  @token = @token.next
end

# Ensure that the current token is TK_NUM.
def expect_number
  error_at("expected a number", @token.pos) if @token.kind != TK_NUM
  val = @token.val
  @token = @token.next
  val
end

def at_eof
  @token.kind == TK_EOF
end

# Create a new token and add it as the next token of `cur`.
def new_token(kind, cur, str, pos)
  tok = Token.new
  tok.kind = kind
  tok.str = str
  tok.pos = pos
  cur.next = tok
  tok
end

def startswith(p, q)
  p.include?(q)
end

# Tokenize `user_input` and returns new tokens.
def tokenize
  s = StringScanner.new(@user_input)
  head = Token.new
  head.str = ""
  head.next = nil
  cur = head

  until s.eos? do
    # Skip whitespace characters.
    next if s.scan(/\s+/)

    # Multi-letter punctuator
    if s.scan(/(==)|(!=)|(<=)|(>=)/)
      cur = new_token(TK_RESERVED, cur, s[0], s.pos - s.matched_size)
      next
    end

    # Single-letter punctuator
    if s.scan(/[\+\-\*\/\(\)<>]/)
      cur = new_token(TK_RESERVED, cur, s[0], s.pos - s.matched_size)
      next
    end

    # Integer literal
    if s.scan(/[0-9]+/)
       cur = new_token(TK_NUM, cur, s[0], s.pos - s.matched_size)
       cur.val = s[0].to_i
       next
    end

    error_at("invalid token", s.pos)
  end

  new_token(TK_EOF, cur, "", s.pos)

  # cur = head.next
  # while cur do
  #   p "#{cur.kind}: #{cur.str}"
  #   cur = cur.next
  # end

  head.next
end

#
# Parser
#

ND_ADD = 0 # +
ND_SUB = 1 # -
ND_MUL = 2 # *
ND_DIV = 3 # /
ND_EQ  = 4 # ==
ND_NE  = 5 # !=
ND_LT  = 6 # <
ND_LE  = 7 # <=
ND_NUM = 8 # Integer

# AST node type
Node = Struct.new(
  :kind,   # Node kind
  :lhs,    # Left-hand side
  :rhs,    # Right-hand side
  :val,    # Used if kind == ND_NUM
)

def new_node(kind)
  node = Node.new
  node.kind = kind
  node
end

def new_binary(kind, lhs, rhs)
  node = new_node(kind)
  node.lhs = lhs
  node.rhs = rhs
  node
end

def new_num(val)
  node = new_node(ND_NUM)
  node.val = val
  node
end

# expr = equality
def expr
  equality()
end

# equality = relational ("==" relational | "!=" relational)*
def equality
  node = relational()

  loop do
    if consume("==")
      node = new_binary(ND_EQ, node, relational())
    elsif consume("!=")
      node = new_binary(ND_NE, node, relational())
    else
      return node
    end
  end
end

# relational = add ("<" add | "<=" add | ">" add | ">=" add)*
def relational
  node = add()

  loop do
    if consume("<")
      node = new_binary(ND_LT, node, add())
    elsif consume("<=")
      node = new_binary(ND_LE, node, add())
    elsif consume(">")
      node = new_binary(ND_LT, add(), node)
    elsif consume(">=")
      node = new_binary(ND_LE ,add(), node)
    else
      return node
    end
  end
end

# add = mul ("+" mul | "-" mul)*
def add
  node = mul()

  loop do
    if consume("+")
      node = new_binary(ND_ADD, node, mul())
    elsif consume("-")
      node = new_binary(ND_SUB, node, mul())
    else
      return node
    end
  end
end

# mul = unary ("*" unary | "/" unary)*
def mul
  node = unary()

  loop do
    if consume("*")
      node = new_binary(ND_MUL, node, unary())
    elsif consume("/")
      node = new_binary(ND_DIV, node, unary())
    else
      return node
    end
  end
end

# unary = ("+" | "-")? unary
#       | primary
def unary
  if consume("+")
    unary()
  elsif consume("-")
    new_binary(ND_SUB, new_num(0), unary())
  else
    primary()
  end
end

# primary = "(" expr ")" | num
def primary
  if consume("(")
    node = expr()
    expect(")")
    return node
  end

  new_num(expect_number())
end

#
# Code generator
#

def gen(node)
  if node.kind == ND_NUM
    puts("  push #{node.val}")
    return
  end

  gen(node.lhs)
  gen(node.rhs)
  
  puts("  pop rdi")
  puts("  pop rax")

  case node.kind
  when ND_ADD
    puts("  add rax, rdi")
  when ND_SUB
    puts("  sub rax, rdi")
  when ND_MUL
    puts("  imul rax, rdi")
  when ND_DIV
    puts("  cqo")
    puts("  idiv rdi")
  when ND_EQ
    printf("  cmp rax, rdi\n")
    printf("  sete al\n")
    printf("  movzb rax, al\n")
  when ND_NE
    printf("  cmp rax, rdi\n")
    printf("  setne al\n")
    printf("  movzb rax, al\n")
  when ND_LT
    printf("  cmp rax, rdi\n")
    printf("  setl al\n")
    printf("  movzb rax, al\n")
  when ND_LE
    printf("  cmp rax, rdi\n")
    printf("  setle al\n")
    printf("  movzb rax, al\n")
  end

  puts("  push rax")
end

#
# main
# 
if ARGV.length != 1
  error("#{ARGV.length}: invalid number of arguments")
end

# Tokenize and parse.
@user_input = ARGV[0]
@token = tokenize()
node = expr()

# Print out the first half of assembly.
puts(".intel_syntax noprefix")
puts(".globl main")
puts "main:"

# Traverse the AST to emit assembly.
gen(node)

# A result must be at the top of the stack, so pop it
# to RAX to make it a program exit code.
puts("  pop rax");
puts("  ret");
